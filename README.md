# pyGimli_dev
+ pyGIMLi整合開發紀錄
+ 最後更新: HsiupoYeh 20240430a
+ pyGIMLi is an open-source library for multi-method modelling and inversion in geophysics.
```
Rücker, C., Günther, T., Wagner, F.M., 2017. pyGIMLi: An open-source library for modelling and inversion in geophysics, Computers and Geosciences, 109, 106-123, doi: 10.1016/j.cageo.2017.07.011.
```

### 來源:
+ 官網: https://www.pygimli.org/
+ Github: https://github.com/gimli-org/gimli
+ 授權: Apache 2.0
  + 可商用，但要註明保留原作者權利。
+ Python版本限制: 使用3.7以後的穩定版本。但其他相依套件可能有不同版本需求。

### 簡介:
+ pyGIMLI的ERT
  + 核心運算數值方法: 有限元素法(Finite Element Method, FEM)。
  + 順推計算: 採用有限元素法 (FEM) 來數值求解描述地下電流分佈和電位場的偏微分方程 (PDE) 。
    1. 地電阻的順推的偏微分方程 (PDE) 是利用歐姆定律和電荷守恆定律，在穩態直流電場這個物理場景中所建構出來的數學模型。
    2. 地電阻的順推問題在數學上就是一個包含點源（A 電極注入電流）和點匯（B 電極引出電流）的偏微分方程邊界值問題。
    3. 在 PyGimli 的地電阻 (ERT) 模組中，用於求解偏微分方程 (PDE) 的邊界值問題時，會使用以下幾種常見的邊界條件：  
        + 絕緣邊界條件 (Neumann Boundary Condition)：
          + 物理意義： 模擬一個不導電的邊界。
          + 在 ERT 中的應用： 通常用於地表（除了電極點），以及作為建模區域底部和側面人工邊界的一種選擇，特別是當這些邊界設置得足夠遠時，可以假設電流不會流到或流出這些遠處邊界。
        + 固定電位邊界條件 (Dirichlet Boundary Condition)：
          + 物理意義： 模擬一個具有已知電位值的邊界。
          + 在 ERT 中的應用： 有時用於建模區域底部和側面的人工邊界，例如設定最深處或最遠處邊界電位為 0，假設電位在足夠遠處衰減到零。
        + 混合邊界條件 (Mixed Boundary Condition)：
          + 物理意義： 模擬更複雜的邊界行為，例如同時考慮電位和電流的約束。
          + 在 ERT 中的應用： PyGimli 的預設「世界邊界條件」（當你在 createWorld 中設定 worldMarkers=True 時）在處理側面和底部邊界時，常常實現為一種混合邊界條件。這種條件比單純的絕緣邊界在數值上更穩定，並能更好地模擬電位在遠處的自然衰減，而無需將邊界設置得極遠。
        + 電極源匯條件 (Electrode Source/Sink Conditions)：
          + 物理意義： 模擬電流從 A 電極注入地下，從 B 電極流出地下。
          + 在 ERT 中的應用： 這不是施加在外部建模區域邊界上的條件，而是在建模區域內部，電極所在的網格節點或元素上進行處理。PyGimli 的正演模擬器 (ert.ERTModelling) 會根據電極位置和注入電流大小，在對應的網格位置上施加這些源/匯條件，然後求解整個區域的電位場。
    4. 進行地電阻的順推計算（正向模擬，使用 FEA 求解 PDE）時，你必須提供一個有限元素網格 (Mesh)。
        + 這個網格定義了你進行模擬的整個地下區域的幾何形狀和範圍，包括它的邊界。而更準確地說，除了提供定義了幾何邊界的網格本身，你還需要為這個網格的邊界設定（定義）對應的物理邊界條件（例如地表是絕緣邊界，底部和側面是混合邊界等）。
    5. 順推計算將模擬單位電流 (例如 1 安培) 從 A 電極注入、從 B 電極引出時，在整個建模區域內產生的電位場分佈 (V)，單位:伏特。可以利用這個結果來計算針對任何 ABMN 電極組合的觀測量。常見為I_AB=1[A]，計算出V_mn[V]、R_ABMN[Ohm]、Rhoa_ABMN[Ohm-m]。ABMN的位置要求是必須在建模區域內(包含網格邊界與網格內部)，可設置於建模區域內的任意位置，例如井下電極所在位置；也可以設置於地表邊界上，例如地表電極所在位置。

  + 逆推計算: 採用高斯牛頓法 (Gauss-Newton method) 來求解。這是一種迭代優化演算法，用於尋找最佳的地下模型，以最小化理論數據與觀測數據之間的差異。
    + 逆推問題簡化的數學模型為 d=G(m)。d為資料，G為前向算子 (負責將模型轉換為理論資料，可以是線性或非線性的) ，m為模型。一般而言，G依照理論建構，d為觀測量，m為所求。
    + ERT為非線性的向前算子。逆推計算需使用迭代的方式求解，逐步逼近最佳解。求解方法常見的有:
      + 高斯-牛頓法 (Gauss-Newton method)
      + Levenberg-Marquardt 法 (L-M method)，基於高斯-牛頓框架，PyGimli 採用此方法，允許動態改變lam。
      + 最速下降法 (Steepest Descent)
      + 共軛梯度法 (Conjugate Gradient method, CG)
      + 擬牛頓法 (Quasi-Newton methods, 例如 BFGS, L-BFGS)
    + 逆推問題的本質是利用有限的觀測資料 (Nd個數據) 去求解一個參數數量通常也有限的模型 (Nm個參數)。
      + 因此，選擇合適的Nd與Nm之間的比例是必要的，以提供足夠的來自數據的約束，期待不會發生「欠定(underdetermined)」的狀態。
      + 由於：數據雜訊 (Data Noise)、資料特性（例如，敏感度分佈不均，數據之間存在相關性或冗餘，導致來自數據的有效獨立信息量少於數據點數量）、物理問題固有的病態性 (Ill-posedness)，即使觀測資料數量 (Nd) 在數量上看似足夠（例如 Nd>Nm），問題在某些模型參數上仍然可能屬於「欠定(underdetermined)」的狀態。
      + 在「欠定(underdetermined)」的情況下，必須依賴正規化來獲得穩定的解。正規化並不是隨機地「猜」模型，而是根據我們對地下構造的先驗假設（例如，地下構造是相對平滑的，或者由幾個不同的區域組成）來引入額外的約束。它指導反演演算法在眾多可能解釋數據（在誤差範圍內）的模型中，選擇那個最符合正規化準則的模型。正規化在數據信息不足的區域起主導作用，它用先驗信息「填補」數據信息的不足，從而穩定求解並得到一個地質上相對合理的結果。
      + 在ERT逆推中，核心挑戰在於在模型的複雜度（由網格細密程度決定的參數數量 Nm）與觀測數據提供的信息量（數據數量 Nd、質量及敏感度分佈）之間找到平衡。
        + 當網格過細（Nm過大）而數據不足（Nd過小）時，問題將變得嚴重欠定 (severely underdetermined)。此時，數據提供的約束遠不足以唯一確定所有模型參數，反演將高度不穩定，過度依賴正規化來填補數據的空白，可能導致多種模型都能擬合數據，而難以獲得可靠的地質解釋。
        + 反之，若網格過粗（Nm過小）而數據豐沛（Nd過大）時，數學上雖是超定 (overdetermined) 的，但模型的表示能力有限，難以充分擬合大量數據中包含的所有細節。這會導致數據擬合困難，且反演結果的解析度被限制在粗糙的網格尺度上，無法利用多餘數據來解析更精細的構造，浪費了數據潛力。
        + 因此，網格設計應與數據信息量相稱，選擇一個恰當的網格細密程度，既要提供足夠的模型參數來捕捉數據所能解析的細節，亦要避免過於複雜而陷入嚴重欠定，以導引出穩定、可靠且能合理擬合觀測數據的地下模型。
        + 如果有很多的數據，想要降低數量，可以考慮選擇敏感度閾值篩選。
        ```python
        import pygimli as pg
        import pygimli.meshtools as mt
        from pygimli.ert import createDataContainer, ERTManager
        import numpy as np
        import matplotlib.pyplot as plt
        # 確保可以顯示中文
        plt.rcParams['font.sans-serif'] = ['Arial Unicode MS'] # 或其他支持中文的字體
        plt.rcParams['axes.unicode_minus'] = False
        
        # --- 1. 建立一個簡單的地電阻測量幾何和網格 ---
        # 定義電極位置 (沿 x 軸)
        electrode_positions = np.linspace(0, 10, 11) # 11個電極，間距1米
        # 建立一個簡單的測量佈置，例如 Wenner
        # 這裡只用於定義數據點的數量和結構，不包含實際量測值
        data_container = createDataContainer(electrode_positions, elTyp='Wenner')
        Nd = data_container.size() # 數據點數量
        print(f"建立包含 {Nd} 個數據點的資料容器 (DataContainer)")
        
        # 建立一個適合這個測線的網格，用於正向計算和模型參數化
        # 通常網格會比電極範圍更廣更深，並在測量區域附近更細密
        mesh = mt.createParaMesh(electrode_positions, verbose=False)
        # 增加深度和橫向範圍，並細化網格 (這裡僅為示例)
        mesh = mt.createMesh(mesh, refine=True, nCols=15, nRows=10)
        mesh = mesh.createP2() # 將網格轉換為二次基函數 (P2)，適合 FEM 正向計算
        Nm = mesh.cellCount() # 網格單元數量 (每個單元通常對應一個模型參數)
        print(f"建立包含 {Nm} 個網格單元的模型網格 (Mesh)")
        print(f"數據點數量 ({Nd}) 與網格單元數量 ({Nm}) 的比例大致為 {Nd}:{Nm} = {Nd/Nm:.2f}:1")
        
        # --- 2. 建立順推算子 ForwardOperator ---
        # ERTManager 是一個方便的類，它內部會建立和管理 ForwardOperator 和 Inversion 物件
        # 雖然這裡沒有觀測數據，但我們需要 ERTManager 來設定 ForwardOperator 的網格和數據結構
        manager = ERTManager(data=data_container, mesh=mesh)
        fop = manager.fop # 取得 ForwardOperator 物件
        
        # 敏感度計算需要一個模型作為輸入。
        # 這裡使用一個簡單的均勻模型作為計算敏感度的代表性模型。
        # 在實際應用中，你也可以使用通過快速初步反演獲得的模型，它可能更接近真實地下情況，計算出的敏感度也更具參考價值。
        homogeneous_conductivity = 0.1 # 設定一個均勻電導率值 (例如 0.1 S/m)
        model_for_sensitivity = np.full(Nm, homogeneous_conductivity) # 建立模型向量
        
        # 將用於計算敏感度的模型設定給 ForwardOperator
        fop.setModel(model_for_sensitivity)
        
        # --- 3. 計算敏感度矩陣 (Jacobian) ---
        # jacobian() 方法會計算在目前設定的模型下的敏感度矩陣 J
        # J 是一個 Nd x Nm 的矩陣，J[i, j] 表示第 i 個數據點對第 j 個模型單元的敏感度
        J = fop.jacobian()
        print(f"計算敏感度矩陣 J, 形狀為 {J.shape} (數據點數 x 模型參數數)")
        
        # --- 4. 計算每個數據點的敏感度衡量標準 ---
        # 敏感度矩陣 J 的每一行對應一個數據點。我們計算每個數據點（每一行）的敏感度衡量值。
        # 這些值可以衡量每個數據點對整個模型（或特定區域）的總體敏感度影響。
        sensitivity_measures = {}
        
        # 最大絕對敏感度：每個數據點對模型參數的最大敏感度 (max(abs(J[i, :])))
        # 衡量一個數據點對地下「最敏感」區域的影響力
        sensitivity_measures['最大絕對敏感度'] = np.max(np.abs(J), axis=1)
        
        # 絕對敏感度之和：每個數據點對所有模型參數的絕對敏感度之和 (sum(abs(J[i, :])))
        # 衡量一個數據點對整個地下模型的總體影響力
        sensitivity_measures['絕對敏感度總和'] = np.sum(np.abs(J), axis=1)
        
        # L2 範數 (Root-Mean-Square Sensitivity): 另一種衡量總體敏感度的方法 (sqrt(sum(J[i, :]^2)))
        sensitivity_measures['L2範數'] = np.linalg.norm(J, axis=1)
        
        print(f"計算了 {Nd} 個數據點的敏感度衡量值 ({', '.join(sensitivity_measures.keys())})")
        
        # --- 5. 分析敏感度衡量值的分布 ---
        # 使用直方圖來可視化不同敏感度衡量值的分布情況
        plt.figure(figsize=(15, 5)) # 調整圖形大小
        
        for i, (name, values) in enumerate(sensitivity_measures.items()):
            plt.subplot(1, len(sensitivity_measures), i + 1) # 根據衡量標準數量創建子圖
            # 繪製直方圖，使用對數軸以便看清低敏感度數據點的分布
            plt.hist(values, bins=50, log=True, edgecolor='black', alpha=0.7)
            plt.title(f"{name} 的分布")
            plt.xlabel("敏感度衡量值")
            plt.ylabel("數據點數量 (對數軸)")
            plt.grid(True, which='both', linestyle='--', alpha=0.6)
        
        plt.tight_layout() # 自動調整子圖間距
        plt.show()
        
        # 使用統計摘要來了解分布特徵，這有助於決定閾值
        print("\n敏感度衡量值的統計摘要:")
        for name, values in sensitivity_measures.items():
            print(f"  {name}:")
            print(f"    最小值 (Min): {np.min(values):.4e}") # 科學記號顯示
            print(f"    最大值 (Max): {np.max(values):.4e}")
            print(f"    平均值 (Mean): {np.mean(values):.4e}")
            print(f"    中位數 (Median): {np.median(values):.4e}")
            print(f"    標準差 (StdDev): {np.std(values):.4e}")
            # 計算一些百分位數，例如第 5, 10, 25, 50, 75, 90, 95, 99 百分位
            percentiles = np.percentile(values, [5, 10, 25, 50, 75, 90, 95, 99])
            print(f"    百分位數 (5, 10, 25, 50, 75, 90, 95, 99): [{', '.join(['{:.4e}'.format(p) for p in percentiles])}]")
        
        
        # --- 6. 決定門檻 (Threshold) ---
        # 根據步驟 5 的分布分析，來決定一個合適的閾值。
        # 例如，你觀察直方圖後，決定移除那些「最大絕對敏感度」位於最低的 15% 的數據點。
        chosen_measure_name = '最大絕對敏感度' # 選擇基於最大絕對敏感度
        chosen_measure_values = sensitivity_measures[chosen_measure_name]
        
        threshold_percentile_to_remove = 15 # 決定移除最低的 15% 的數據點
        threshold_value = np.percentile(chosen_measure_values, threshold_percentile_to_remove)
        
        print(f"\n根據 '{chosen_measure_name}' 的分布，決定移除位於最低 {threshold_percentile_to_remove}% 的數據點")
        print(f"計算出的敏感度閾值為: {threshold_value:.4e}")
        
        # --- 7. 基於門檻選擇數據點 ---
        # 找出敏感度衡量值大於或等於閾值的數據點索引，這些是要保留的點
        retained_indices = np.where(chosen_measure_values >= threshold_value)[0]
        # 找出敏感度衡量值小於閾值的數據點索引，這些是要移除的點
        removed_indices = np.where(chosen_measure_values < threshold_value)[0]
        
        print(f"\n原始數據點數量: {Nd}")
        print(f"保留的數據點數量: {len(retained_indices)}")
        print(f"移除的數據點數量: {len(removed_indices)}")
        print(f"移除比例: {len(removed_indices) / Nd:.2%}")
        
        # 從原始數據容器中選擇數據：
        # 如果你的原始觀測數據儲存在一個叫做 original_data_container 的 PyGimli DataContainer 物件中，
        # 你可以使用 .select() 方法來創建一個包含保留數據點的新容器。
        # 這裡我們使用上面建立的 dummy data_container 來示範
        # original_data_container = pg.load("your_measured_data.dat") # 假設你從文件載入數據
        selected_data_container = data_container.select(retained_indices)
        
        
        print(f"\n建立了包含 {selected_data_container.size()} 個保留數據點的新資料容器 (DataContainer)。")
        print("這個新的資料容器 (selected_data_container) 可以用於後續的反演計算 (例如 manager.setData(selected_data_container))。")
        
        # --- 實際應用注意事項 ---
        print("\n--- 實際應用注意事項 ---")
        print("1. **代表性模型**：用於計算敏感度的模型會影響 J。均勻模型是簡化，通常用初步反演結果計算敏感度更佳。")
        print("2. **閾值選擇**：沒有硬性規則，需要根據數據品質、地質目標和試錯來決定。視覺化分布和統計摘要是關鍵。")
        print("3. **敏感度衡量標準**：max_abs, sum_abs, L2 norm 等有不同含義，可以嘗試不同標準看看效果。max_abs 對於識別對『某個』參數敏感的數據有用，sum_abs/L2 norm 則衡量數據對整個模型的總體影響力。")
        print("4. **丟失獨特敏感度**：即使總體敏感度低，某些數據點可能對地下某個特定區域具有獨特（即使微弱）的敏感度。簡單按閾值移除可能完全失去對該區域的數據約束，需要謹慎。")
        print("5. **與雜訊關係**：理論上，閾值應與數據點的雜訊水平相結合考慮。例如，如果一個模型參數的潛在變化乘以敏感度小於數據雜訊，那麼這個數據點就無法分辨該參數的變化。")
        print("6. **迭代過程**：敏感度閾值篩選通常作為反演前的預處理步驟。但更進階的方法可能會在反演迭代過程中動態調整數據權重（如穩健反演）或進行數據選擇。")
        ```
### 安裝miniconda(在Windows 10)
+ 作業系統: Windows 10
+ https://docs.anaconda.com/free/miniconda/
  + https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe
  + 安裝時不需要網路

### 建立環境並安裝pyGimli與相依套件
+ 安裝命令:
  ```
  conda create -n pg -c gimli -c conda-forge "pygimli>=1.5.0"
  ```
> 實際環境的檔案位置:「C:\Users\USER\miniconda3\envs」

+ 啟用環境
  ```
  conda activate pg
  ```

+ 安裝auto-py-to-exe
  ```
  conda activate pg  
  ```
  ```
  pip install auto-py-to-exe  
  ```  


### ERT資料格式
+ 參考: http://resistivity.net/bert/data_format.html
```
#============================================================
# Data Format: unified data format(*.ohm)
# REF: http://resistivity.net/bert/data_format.html
# Description: 
#     pyGIMLI 2D ERT  Input data Example
# 注意事項:
#   HsiupoYeh 2024-04-29整理，適用pyGIMLI v.1.5.0
#   請不要總是從編號1開始使用?
#   編號0表示位置無限遠
#   所有資料可以用空白或tab分隔。
#   註解用「#」
#============================================================

#------------------------------------------------------------
# 在2D的情況下，電極定義為「#x z」。
# x 單位公尺，側向位置向右為正。
# z 單位公尺，高程向上為正。
# 注意: 讀檔程式不聰明，電極數量寫在本區塊某一行，其下一行必須是「#x z」。
#       這個「#x z」不是註解，讀檔要解析...
#--
# 電極數量:
38
#x z
0	108.8
1.5692	110.04
3.13841	111.28
4.70761	112.52
6.27681	113.76
7.84602	115
9.41522	116.24
10.9844	117.48
12.5536	118.72
14.1228	119.96
15.692	121.2
17.692	121.2
19.692	121.2
21.692	121.2
23.692	121.2
25.692	121.2
27.692	121.2
29.692	121.2
31.692	121.2
33.452	120.25
35.212	119.3
37.212	119.3
39.212	119.3
41.212	119.3
43.1405	118.77
44.8365	117.71
46.5325	116.65
48.2285	115.59
49.9245	114.53
51.853	114
53.853	114
55.853	114
57.853	114
59.5167	112.89
61.1804	111.78
62.8441	110.67
64.5078	109.56
66.1715	108.45
#------------------------------------------------------------

#------------------------------------------------------------
# 注意: 讀檔程式不聰明，觀測資料數量寫在本區塊某一行，其下一行必須是「#A B M N R」。
#       這個「#A B M N R」不是註解，讀檔要解析...
#       A,B,M,N均為電極編號，以上方區塊電極位置的順序當作編號，第一個電極為編號1。
#       R為AB電流與MN電壓比值(V_MN/I_AB)，單位「Ohm」。
# 觀測資料數量:
222
#A B M N R
1	4	2	3	1.18411
2	5	3	4	1.54858
3	6	4	5	1.6202
4	7	5	6	1.87962
5	8	6	7	1.87723
6	9	7	8	1.76025
7	10	8	9	1.87644
8	11	9	10	1.85018
9	12	10	11	2.27592
10	13	11	12	1.78254
11	14	12	13	1.41966
12	15	13	14	1.87644
13	16	14	15	1.50561
14	17	15	16	1.64487
15	18	16	17	1.42125
16	19	17	18	1.8088
17	20	18	19	0.904796
18	21	19	20	2.02923
19	22	20	21	1.582
20	23	21	22	2.05787
21	24	22	23	2.06901
22	25	23	24	1.808
23	26	24	25	1.89951
24	27	25	26	1.88996
25	28	26	27	1.70057
26	29	27	28	2.29183
27	30	28	29	1.93055
28	31	29	30	2.66982
29	32	30	31	1.55574
30	33	31	32	2.54409
31	34	32	33	0.962092
32	35	33	34	1.98148
33	36	34	35	1.5263
34	37	35	36	1.90031
35	38	36	37	2.31968
1	7	3	5	0.534363
2	8	4	6	0.705852
3	9	5	7	0.664472
4	10	6	8	0.614338
5	11	7	9	0.543912
6	12	8	10	0.647761
7	13	9	11	1.00586
8	14	10	12	0.763546
9	15	11	13	0.451602
10	16	12	14	0.440859
11	17	13	15	0.697497
12	18	14	16	0.55744
13	19	15	17	0.535954
14	20	16	18	0.491391
15	21	17	19	0.377993
16	22	18	20	0.494176
17	23	19	21	0.761954
18	24	20	22	0.915141
19	25	21	23	0.854662
20	26	22	24	0.758373
21	27	23	25	0.758771
22	28	24	26	0.797366
23	29	25	27	0.885697
24	30	26	28	0.839144
25	31	27	29	0.880127
26	32	28	30	0.937423
27	33	29	31	0.808507
28	34	30	32	0.651342
29	35	31	33	0.483831
30	36	32	34	0.492982
31	37	33	35	0.510092
32	38	34	36	0.733306
1	10	4	7	0.377728
2	11	5	8	0.304782
3	12	6	9	0.268707
4	13	7	10	0.324941
5	14	8	11	0.448552
6	15	9	12	0.427066
7	16	10	13	0.363404
8	17	11	14	0.245629
9	18	12	15	0.222552
10	19	13	16	0.315923
11	20	14	17	0.343244
12	21	15	18	0.30823
13	22	16	19	0.220695
14	23	17	20	0.275073
15	24	18	21	0.396561
16	25	19	22	0.593383
17	26	20	23	0.642986
18	27	21	24	0.54484
19	28	22	25	0.350141
20	29	23	26	0.339531
21	30	24	27	0.341122
22	31	25	28	0.494441
23	32	26	29	0.613012
24	33	27	30	0.73397
25	34	28	31	0.54988
26	35	29	32	0.497094
27	36	30	33	0.24112
28	37	31	34	0.208493
29	38	32	35	0.215124
1	13	5	9	0.199938
2	14	6	10	0.225204
3	15	7	11	0.231968
4	16	8	12	0.219236
5	17	9	13	0.216252
6	18	10	14	0.210283
7	19	11	15	0.1695
8	20	12	16	0.167511
9	21	13	17	0.19596
10	22	14	18	0.188002
11	23	15	19	0.190389
12	24	16	20	0.206504
13	25	17	21	0.282898
14	26	18	22	0.390526
15	27	19	23	0.442849
16	28	20	24	0.348748
17	29	21	25	0.273747
18	30	22	26	0.163134
19	31	23	27	0.131502
20	32	24	28	0.18462
21	33	25	29	0.306373
22	34	26	30	0.489401
23	35	27	31	0.491391
24	36	28	32	0.38615
25	37	29	33	0.282102
26	38	30	34	0.134486
1	16	6	11	0.156608
2	17	7	12	0.155972
3	18	8	13	0.133849
4	19	9	14	0.139261
5	20	10	15	0.140216
6	21	11	16	0.121594
7	22	12	17	0.120799
8	23	13	18	0.136396
9	24	14	19	0.129234
10	25	15	20	0.160428
11	26	16	21	0.232685
12	27	17	22	0.289025
13	28	18	23	0.262128
14	29	19	24	0.232207
15	30	20	25	0.149606
16	31	21	26	0.126528
17	32	22	27	0.108862
18	33	23	28	0.126528
19	34	24	29	0.147537
20	35	25	30	0.217406
21	36	26	31	0.258627
22	37	27	32	0.310193
23	38	28	33	0.25433
1	19	7	13	0.101594
2	20	8	14	0.116316
3	21	9	15	0.101461
4	22	10	16	0.0961561
5	23	11	17	0.0870047
6	24	12	18	0.0946972
7	25	13	19	0.105573
8	26	14	20	0.126263
9	27	15	21	0.173479
10	28	16	22	0.191251
11	29	17	23	0.188864
12	30	18	24	0.124539
13	31	19	25	0.111143
14	32	20	26	0.103053
15	33	21	27	0.1004
16	34	22	28	0.107297
17	35	23	29	0.117509
18	36	24	30	0.144831
19	37	25	31	0.13064
20	38	26	32	0.14125
1	22	8	15	0.0782133
2	23	9	16	0.0853753
3	24	10	17	0.0787817
4	25	11	18	0.0735523
5	26	12	19	0.075826
6	27	13	20	0.10004
7	28	14	21	0.120503
8	29	15	22	0.136191
9	30	16	23	0.109362
10	31	17	24	0.0970845
11	32	18	25	0.0923099
12	33	19	26	0.0946972
13	34	20	27	0.0919688
14	35	21	28	0.0978803
15	36	22	29	0.0982213
16	37	23	30	0.112318
17	38	24	31	0.102655
1	25	9	17	0.0556048
2	26	10	18	0.0741065
3	27	11	19	0.0621699
4	28	12	20	0.0679393
5	29	13	21	0.0870379
6	30	14	22	0.0831585
7	31	15	23	0.0859437
8	32	16	24	0.0807711
9	33	17	25	0.0808706
10	34	18	26	0.0798759
11	35	19	27	0.088132
12	36	20	28	0.0913151
13	37	21	29	0.0899225
14	38	22	30	0.0961893
1	28	10	19	0.0508412
2	29	11	20	0.0565
3	30	12	21	0.0560579
4	31	13	22	0.0641041
5	32	14	23	0.0681714
6	33	15	24	0.071885
7	34	16	25	0.0721502
8	35	17	26	0.0717966
9	36	18	27	0.0731229
10	37	19	28	0.0823185
11	38	20	29	0.0908067
1	31	11	21	0.0486218
2	32	12	22	0.0541127
3	33	13	23	0.060638
4	34	14	24	0.0614338
5	35	15	25	0.0635824
6	36	16	26	0.0640599
7	37	17	27	0.0651739
8	38	18	28	0.0686754
1	34	12	23	0.0468784
2	35	13	24	0.0571511
3	36	14	25	0.056283
4	37	15	26	0.0569341
5	38	16	27	0.0572958
1	37	13	25	0.0452265
2	38	14	26	0.0510622
#------------------------------------------------------------
```
