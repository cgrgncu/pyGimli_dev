# 程式碼分析
+ 作者:HsiupoYeh
+ 更新日期: 2025-10-25
+ REF:
  + Rücker, C., Günther, T., & Spitzer, K. (2006). Three-dimensional modelling and inversion of dc resistivity data incorporating topography—I. Modelling. Geophysical Journal International, 166(2), 495-505.
  + Günther, T., Rücker, C., & Spitzer, K. (2006). Three-dimensional modelling and inversion of DC resistivity data incorporating topography—II. Inversion. Geophysical Journal International, 166(2), 506-517.

### 範例來源
+ https://www.pygimli.org/_examples_auto/3_ert/plot_01_ert_2d_mod_inv.html

### 引入
```python
import matplotlib.pyplot as plt
import numpy as np

import pygimli as pg
import pygimli.meshtools as mt
from pygimli.physics import ert
```
+ 用到繪圖、數值計算
+ 科學的部分用到pygimli，整個pg可能都被用到(對應資料夾「pygiml」)
+ 特別還會用到一些內部的meshtools，(對應資料夾「pygiml\meshtools」)
+ 特別還會用到一些內部的ert，(對應資料夾「pygimli\physics\ert」)

### 建立網格
+ 這部分我不好奇，但是稍微提醒這部分建立了網格、邊界、填入電阻率(線性)、側面底部會設定成最小數字的邊界編號。
+ 可以用「pg.show(geom)」去展示網格。

### 產生空的資料(ABMN資料集=*.ohm檔案)
+ 關鍵點: 準備mesh，放入ABMN清單，開始跑順推
```
data = ert.simulate(mesh, scheme=scheme, res=rhomap, noiseLevel=1,
                    noiseAbs=1e-6, seed=1337)
```
+ 這裡要開始追ert.simulate到底在幹嘛:
  + 位置「pygimli\physics\ert\ert.py」
  + 關心其註解:
  ```
  """Simulate an ERT measurement.

    Perform the forward task for a given mesh, resistivity distribution &
    measuring scheme and return data (apparent resistivity) or potentials.

    For complex resistivity, the data contains an apparent phase or the
    returned potentials are complex.

    The forward operator itself only calculates potential values for the
    electrodes in the given data scheme.
    To calculate apparent resistivities, geometric factors (k) are needed.
    If there are no values k in the DataContainerERT scheme, the function
    tries to calculate them, either analytically or numerically by using a
    p2-refined version of the given mesh.

    TODO
    ----
    * 2D + Complex + SR

    Args
    ----
    mesh : :gimliapi:`GIMLI::Mesh`
        2D or 3D Mesh to calculate for.

    res : float, array(mesh.cellCount()) | array(N, mesh.cellCount()) |
          list
        Resistivity distribution for the given mesh cells can be:
        . float for homogeneous resistivity (e.g. 1.0)
        . single array of length mesh.cellCount()
        . matrix of N resistivity distributions of length mesh.cellCount()
        . resistivity map as [[regionMarker0, res0],
                              [regionMarker0, res1], ...]

    scheme : :gimliapi:`GIMLI::DataContainerERT`
        Data measurement scheme.

    Keyword Args
    ------------
    verbose: bool[False]
        Be verbose. Will override class settings.
    calcOnly: bool [False]
        Use fop.calculate instead of fop.response. Useful if you want
        to force the calculation of impedances for homogeneous models.
        No noise handling. Solution is put as token 'u' in the returned
        DataContainerERT.
    noiseLevel: float [0.0]
        add normally distributed noise based on
        scheme['err'] or on noiseLevel if error>0 is not contained
    noiseAbs: float [0.0]
        Absolute voltage error in V
    returnArray: bool [False]
        Returns an array of apparent resistivities instead of
        a DataContainerERT
    returnFields: bool [False]
        Returns a matrix of all potential values (per mesh nodes)
        for each injection electrodes.
    sr : bool
        use secondary field (singularity removal)
    seed : int
        numpy.random seed for repeatable noise in synthetic experiments
    phiErr : float|iterable
        absolute phase error, if not given, data['iperr'] or noiseLevel is used
    contactImpedances float|iterables
        contact impedances for being used with CEM model
    current : float
        current to be assumed

    Returns
    -------
    DataContainerERT | array(data.size()) | array(N, data.size()) |
    array(N, mesh.nodeCount()):
        Data container with resulting apparent resistivity data['rhoa'] and
        errors (if noiseLevel or noiseAbs is set).
        Optionally return a Matrix of rhoa values
        (for returnArray==True forces noiseLevel=0).
        In case of complex-valued resistivity, phase values are contained in
        data['phia'] or returned as additionally returned array.

    Examples
    --------
    >>> from pygimli.physics import ert
    >>> import pygimli as pg
    >>> import pygimli.meshtools as mt
    >>> world = mt.createWorld(start=[-50, 0], end=[50, -50],
    ...                        layers=[-1, -5], worldMarker=True)
    >>> scheme = ert.createData(
    ...                     elecs=pg.utils.grange(start=-10, end=10, n=21),
    ...                     schemeName='dd')
    >>> for pos in scheme.sensorPositions():
    ...     _= world.createNode(pos)
    ...     _= world.createNode(pos + [0.0, -0.1])
    >>> mesh = mt.createMesh(world, quality=34)
    >>> rhomap = [
    ...    [1, 100. + 0j],
    ...    [2, 50. + 0j],
    ...    [3, 10.+ 1j],
    ... ]
    >>> data = ert.simulate(mesh, res=rhomap, scheme=scheme, verbose=True)
    """

  ```
  + 所以我不會去填contactImpedances，用不到
  + current也不用填，預設會是1.0，單位我猜是安培。
  + 操作細節是去使用ERTModelling，位置「pygimli\physics\ert\ERTModelling.py」
  + 看一下檔案的重要註解:
  ```
  """ERT modelling operator classes.
  * abstract base class providing a plotting function
  * standard BERT modelling class using pygimli.core (C++) functionality
  * 2.5D non-optimized totalfield forward operator for ERT (reference)
  """
  ```
  + 沒錯用了一堆BERT的東西。那些C++的功能都已經被編譯放到「pgcore.libs」資料夾中，變成DLL檔案。
  + 如果想學著用python過過癮自己寫順推，可以看ERTModellingReference裡面用2.5D來處理的示範。但是效率低而且沒有C++寫的完整，並沒有在正式的任何時候使用。
  + 關鍵要呼叫的是ERTModelling
  + 看一下註解:
  ```
      """Forward operator for Electrical Resistivity Tomography.

    Note
    ----
    Convention for complex resistiviy inversion:
    We want to use logarithm transformation for the imaginary part of model
    so we need the startmodel to have positive imaginary parts.
    The sign is flipped back to physical correct assumption before we call
    the response function.
    The Jacobian is calculated with negative imaginary parts and will
    be a conjugated complex block matrix for further calulations.
    """
  ```
  + 對複數問題有特別處理，還好我現在只想知道ERT，不會有複數先跳過。IP之類的才會有複數。
  + 習慣用法就是宣告成一個fop物件，就是繼承很多功能的ERTModelling類別。然後依照特定順序操作，達到順推的目的，操作與計算幾乎都是用C++，繪圖才是用python。
  + 
  + 我感覺呼叫createJacobian是在呼叫C++的「pyGIMLi/core/src/modellingbase.cpp」，是用暴力法。
  

