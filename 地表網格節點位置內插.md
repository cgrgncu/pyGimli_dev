# 地表網格節點位置內插

### 地表網格節點檔案
+ 命名為「*.json」，例如：「XP1.json」。內容要有以下:
```json
{
"GridStyle":"rectangle",
"GridSurfaceNode_Readme":"X[m],Z[m]",
"GridSurfaceNode":[
[0,813.007],
[1,813.066],
[2,813.068],
[3,813.185],
[4,812.873],
[5,813.145],
[6,813.649],
[7,813.882],
[8,813.713],
[9,813.868],
[10,814.04],
[11,814.393],
[12,814.382],
[13,814.489],
[14,814.349],
[15,814.126],
[16,814.035],
[17,813.696],
[18,813.977],
[19,814.02],
[20,813.968],
[21,813.98],
[22,814.006],
[23,814.344],
[24,814.124],
[25,814.28],
[26,814.222],
[27,814.09],
[28,813.919],
[29,813.723],
[30,813.634],
[31,813.444],
[32,813.197],
[33,813.406],
[34,813.3],
[35,813.211],
[36,813.197],
[37,812.852],
[38,812.893],
[39,812.5795],
[40,812.266],
[41,812.3885],
[42,812.511],
[43,812.451],
[44,812.158],
[45,812.278],
[46,812.203],
[47,812.181],
[48,812.99],
[49,813.05],
[50,814.5972],
[51,null],
[52,null],
[53,null],
[54,817.008],
[55,816.981],
[56,816.385],
[57,816.409],
[58,816.421],
[59,817.016],
[60,817.308],
[61,818.08],
[62,818.571],
[63,819.079],
[64,819.638],
[65,820.346],
[66,821.833],
[67,822.459]
]
}
```

### 讀取JSON檔案
```python
import json
import numpy as np
from scipy.interpolate import interp1d

# 指定檔案名稱
json_file_name = 'XP1.json'

try:
    # 開啟並讀取 JSON 檔案
    with open(json_file_name, 'r', encoding='utf-8') as json_file:
        temp_json_data = json.load(json_file)

    # 取得 GridSurfaceNodes 的資料
    temp_grid_surface_node_data = temp_json_data["GridSurfaceNodes"]

    # 將資料轉換為 NumPy 陣列 (使用 object dtype 以容納 nan)
    grid_surface_node_array = np.array(temp_grid_surface_node_data, dtype=object)

    # 分離 X 和原始 Z 座標
    x_coords_original = grid_surface_node_array[:, 0].astype(float)
    z_coords_original = grid_surface_node_array[:, 1].astype(float)

    # 找到非 NaN 值的索引
    non_nan_z_indices = np.where(~np.isnan(z_coords_original))[0]

    # 如果有效的 Z 值不足，視為錯誤並終止程式
    if len(non_nan_z_indices) <= 1:
        print("錯誤：有效的 Z 值不足，無法進行內插。")
        exit(1)
    else:
        # 創建線性內插函數
        interpolate_function = interp1d(x_coords_original[non_nan_z_indices], z_coords_original[non_nan_z_indices], kind='linear', fill_value="extrapolate")

        # 找到 NaN 值的索引
        nan_z_indices = np.where(np.isnan(z_coords_original))[0]

        # 使用內插函數填補 NaN 值到 z_coords_interp
        z_coords_interp = z_coords_original.copy()
        z_coords_interp[nan_z_indices] = interpolate_function(x_coords_original[nan_z_indices])

        # 創建包含 X, 原始 Z 和內插 Z 的新陣列
        interpolated_data = np.column_stack((x_coords_original, z_coords_original, z_coords_interp))
        print("包含 X, 原始 Z 和內插 Z 的資料：")
        print(interpolated_data)

except FileNotFoundError:
    print(f"錯誤：找不到檔案 '{json_file_name}'")
    exit(1)
except json.JSONDecodeError:
    print(f"錯誤：檔案 '{json_file_name}' 不是有效的 JSON 格式")
    exit(1)
except KeyError as e:
    print(f"錯誤：JSON 檔案中找不到鍵 '{e}'")
    exit(1)
except ImportError:
    print("錯誤：找不到 scipy 函式庫，請先安裝 (pip install scipy)")
    exit(1)
except Exception as e:
    print(f"發生未知錯誤： {e}")
    exit(1)

```
### 讀取JSON並且製造水平網格

```python
import json
import numpy as np
from scipy.interpolate import interp1d
import pygimli as pg
import matplotlib.pyplot as plt
from pygimli.meshtools import createParaMesh2DGrid

# 指定檔案名稱
json_file_name = 'XP1.json'

try:
    # 開啟並讀取 JSON 檔案
    with open(json_file_name, 'r', encoding='utf-8') as json_file:
        temp_json_data = json.load(json_file)

    # 取得 GridSurfaceNodes 的資料
    temp_grid_surface_node_data = temp_json_data["GridSurfaceNodes"]

    # 將資料轉換為 NumPy 陣列 (使用 object dtype 以容納 nan)
    grid_surface_node_array = np.array(temp_grid_surface_node_data, dtype=object)

    # 分離 X 和原始 Z 座標
    x_coords_original = grid_surface_node_array[:, 0].astype(float)
    z_coords_original = grid_surface_node_array[:, 1].astype(float)

    # 找到非 NaN 值的索引
    non_nan_z_indices = np.where(~np.isnan(z_coords_original))[0]

    # 如果有效的 Z 值不足，視為錯誤並終止程式
    if len(non_nan_z_indices) <= 1:
        print("錯誤：有效的 Z 值不足，無法進行內插。")
        exit(1)
    else:
        # 創建線性內插函數
        interpolate_function = interp1d(x_coords_original[non_nan_z_indices], z_coords_original[non_nan_z_indices], kind='linear', fill_value="extrapolate")

        # 找到 NaN 值的索引
        nan_z_indices = np.where(np.isnan(z_coords_original))[0]

        # 使用內插函數填補 NaN 值到 z_coords_interp
        z_coords_interp = z_coords_original.copy()
        z_coords_interp[nan_z_indices] = interpolate_function(x_coords_original[nan_z_indices])

        # 創建包含 X, 原始 Z 和內插 Z 的新陣列
        interpolated_data = np.column_stack((x_coords_original, z_coords_original, z_coords_interp))
        print("包含 X, 原始 Z 和內插 Z 的資料：")
        print(interpolated_data)

except FileNotFoundError:
    print(f"錯誤：找不到檔案 '{json_file_name}'")
    exit(1)
except json.JSONDecodeError:
    print(f"錯誤：檔案 '{json_file_name}' 不是有效的 JSON 格式")
    exit(1)
except KeyError as e:
    print(f"錯誤：JSON 檔案中找不到鍵 '{e}'")
    exit(1)
except ImportError:
    print("錯誤：找不到 scipy 函式庫，請先安裝 (pip install scipy)")
    exit(1)
except Exception as e:
    print(f"發生未知錯誤： {e}")
    exit(1)

x_values= interpolated_data[:, 0]
print(x_values)

# 將 NumPy 陣列作為 sensors 參數傳遞給 createParaMesh2DGrid
mesh = createParaMesh2DGrid(sensors=x_values)


# 呼叫 createParaMesh2DGrid 產生參數化反演 2D 網格
# 注意：此函式只參考 X（水平位置），也只會產生平坦的網格
mesh = createParaMesh2DGrid(
    sensors=x_values, # 必要項，X向量，單位:[m]。
    paraDX=1,         # 水平單元寬度係數，預設值=1。填1=網格間距等於相鄰電極間距，填1/2=相鄰網格間距是電極間距的一半，建議填1除某整數。
    paraDZ=1,         # 垂直第一層高度係數，預設值=1。填1=垂直第一層高度等於相鄰電極間距，填1/2=垂直第一層高度是電極間距的一半，建議填1除某整數。
    paraDepth=0,      # 最大深度，單位:[m]，預設值=0。填0=自動計算為 0.4*(xMax-xMin)，單位[m]。
    nLayers=11,       # 垂直網格數量，單位:層，預設值=11。預設值為 11 層。
    boundary=-1,      # 外圍邊界寬度，單位:[m]，預設值-1。填-1=自動設為 4*(xMax-xMin)，單位[m]。
    paraBoundary=2    # 水平兩端延伸係數，預設值=2。填2=從電極向外延2個間距的網格。就是矩形網格稍微加大。
)

# 顯示網格
ax, _ = pg.show(mesh, markers=True, showMesh=True)
plt.show()
```


### 新測試
```python
import json
import numpy as np
from scipy.interpolate import interp1d
import pygimli as pg
import matplotlib.pyplot as plt
from pygimli.meshtools import createParaMesh2DGrid

# 指定檔案名稱
json_file_name = 'XP1.json'

try:
    # 開啟並讀取 JSON 檔案
    with open(json_file_name, 'r', encoding='utf-8') as json_file:
        temp_json_data = json.load(json_file)

    # 取得 GridSurfaceNodes 的資料
    temp_grid_surface_node_data = temp_json_data["GridSurfaceNodes"]

    # 將資料轉換為 NumPy 陣列 (使用 object dtype 以容納 nan)
    grid_surface_node_array = np.array(temp_grid_surface_node_data, dtype=object)

    # 分離 X 和原始 Z 座標
    x_coords_original = grid_surface_node_array[:, 0].astype(float)
    z_coords_original = grid_surface_node_array[:, 1].astype(float)

    # 找到非 NaN 值的索引
    non_nan_z_indices = np.where(~np.isnan(z_coords_original))[0]

    # 如果有效的 Z 值不足，視為錯誤並終止程式
    if len(non_nan_z_indices) <= 1:
        print("錯誤：有效的 Z 值不足，無法進行內插。")
        exit(1)
    else:
        # 創建線性內插函數
        interpolate_function = interp1d(x_coords_original[non_nan_z_indices], z_coords_original[non_nan_z_indices], kind='linear', fill_value="extrapolate")

        # 找到 NaN 值的索引
        nan_z_indices = np.where(np.isnan(z_coords_original))[0]

        # 使用內插函數填補 NaN 值到 z_coords_interp
        z_coords_interp = z_coords_original.copy()
        z_coords_interp[nan_z_indices] = interpolate_function(x_coords_original[nan_z_indices])

        # 創建包含 X, 原始 Z 和內插 Z 的新陣列
        interpolated_data = np.column_stack((x_coords_original, z_coords_original, z_coords_interp))
        print("包含 X, 原始 Z 和內插 Z 的資料：")
        print(interpolated_data)

except FileNotFoundError:
    print(f"錯誤：找不到檔案 '{json_file_name}'")
    exit(1)
except json.JSONDecodeError:
    print(f"錯誤：檔案 '{json_file_name}' 不是有效的 JSON 格式")
    exit(1)
except KeyError as e:
    print(f"錯誤：JSON 檔案中找不到鍵 '{e}'")
    exit(1)
except ImportError:
    print("錯誤：找不到 scipy 函式庫，請先安裝 (pip install scipy)")
    exit(1)
except Exception as e:
    print(f"發生未知錯誤： {e}")
    exit(1)

x_values= interpolated_data[:, 0]
print(x_values)

z_values_interp = interpolated_data[:, 2]  # 提取內插的 Z 值
print(z_values_interp)

# 仿照 createParaMesh2DGrid 產生參數化反演 2D 網格
# 注意：
sensorX=x_values # 必要項，X向量，單位:[m]。
paraDX=1         # 水平單元寬度係數，預設值=1。填1=網格間距等於相鄰電極間距，填1/2=相鄰網格間距是電極間距的一半，建議填1除某整數。
paraDZ=1         # 垂直第一層高度係數，預設值=1。填1=垂直第一層高度等於相鄰電極間距，填1/2=垂直第一層高度是電極間距的一半，建議填1除某整數。
paraDepth=0      # 最大深度，單位:[m]，預設值=0。填0=自動計算為 0.4*(xMax-xMin)，單位[m]。
nLayers=11       # 垂直網格數量，單位:層，預設值=11。預設值為 11 層。
boundary=-1      # 外圍邊界寬度，單位:[m]，預設值-1。填-1=自動設為 4*(xMax-xMin)，單位[m]。
paraBoundary=2    # 水平兩端延伸係數，預設值=2。填2=從電極向外延2個間距的網格。就是矩形網格稍微加大。

mesh = pg.Mesh(2)

eSpacing = abs(sensorX[1] - sensorX[0])

xMin = min(sensorX) - paraBoundary * eSpacing
xMax = max(sensorX) + paraBoundary * eSpacing

if paraDX == 0:
    paraDX = 1.
if paraDZ == 0:
    paraDZ = 1.

dx = paraDX
dz = paraDZ
if eSpacing > 0:
    dx = eSpacing * paraDX

if paraDepth == 0:
    paraDepth = 0.4 * (xMax - xMin)

x = pg.utils.grange(xMin, xMax, dx=dx)
y = -pg.cat([0], pg.utils.grange(dz, paraDepth, n=nLayers, log=True))

mesh.createGrid(x, y[::-1])
mesh.setCellMarkers([2] * mesh.cellCount())

paraXLimits = [xMin, xMax]

if boundary < 0:
    boundary = abs((paraXLimits[1] - paraXLimits[0]) * 4.0)


# 顯示原始網格座標
node_index_to_move = 0
original_position = mesh.node(node_index_to_move).pos()
print(f"原始網格中索引為 {node_index_to_move} 的節點座標: {original_position}")

# 顯示原始網格 (可選)
fig, ax = plt.subplots()
pg.show(mesh, ax=ax, markers=True, showMesh=True, label="Original Mesh")

# 遍歷網格的所有節點並根據 X 值平移 Y 值
for i in range(mesh.nodeCount()):
    node = mesh.node(i)
    current_x = node.pos()[0]

    # 找到最接近的 x_value 的索引
    closest_index = np.argmin(np.abs(x_values - current_x))

    # 使用該索引的 z_values_interp 來平移 Y 座標
    translation_y = z_values_interp[closest_index]
    new_y = node.pos()[1] + translation_y
    node.setPos([current_x, new_y])


# 顯示修改後的節點座標
modified_position = mesh.node(node_index_to_move).pos()
print(f"修改後網格中索引為 {node_index_to_move} 的節點座標: {modified_position}")

# 重新顯示修改後的網格
fig2, ax2 = plt.subplots()
pg.show(mesh, ax=ax2, markers=True, showMesh=True, label="Modified Mesh")

plt.show()
```
