# 地表網格節點位置內插

### 地表網格節點檔案
+ 命名為「*.json」，例如：「XP1.json」。內容要有以下:
```json
{
"GridStyle":"rectangle",
"GridSurfaceNode_Readme":"X[m],Z[m]",
"GridSurfaceNode":[
[0,813.007],
[1,813.066],
[2,813.068],
[3,813.185],
[4,812.873],
[5,813.145],
[6,813.649],
[7,813.882],
[8,813.713],
[9,813.868],
[10,814.04],
[11,814.393],
[12,814.382],
[13,814.489],
[14,814.349],
[15,814.126],
[16,814.035],
[17,813.696],
[18,813.977],
[19,814.02],
[20,813.968],
[21,813.98],
[22,814.006],
[23,814.344],
[24,814.124],
[25,814.28],
[26,814.222],
[27,814.09],
[28,813.919],
[29,813.723],
[30,813.634],
[31,813.444],
[32,813.197],
[33,813.406],
[34,813.3],
[35,813.211],
[36,813.197],
[37,812.852],
[38,812.893],
[39,812.5795],
[40,812.266],
[41,812.3885],
[42,812.511],
[43,812.451],
[44,812.158],
[45,812.278],
[46,812.203],
[47,812.181],
[48,812.99],
[49,813.05],
[50,814.5972],
[51,null],
[52,null],
[53,null],
[54,817.008],
[55,816.981],
[56,816.385],
[57,816.409],
[58,816.421],
[59,817.016],
[60,817.308],
[61,818.08],
[62,818.571],
[63,819.079],
[64,819.638],
[65,820.346],
[66,821.833],
[67,822.459]
]
}
```

### 讀取JSON檔案
```python
import json
import numpy as np
from scipy.interpolate import interp1d

# 指定檔案名稱
json_file_name = 'XP1.json'

try:
    # 開啟並讀取 JSON 檔案
    with open(json_file_name, 'r', encoding='utf-8') as json_file:
        temp_json_data = json.load(json_file)

    # 取得 GridSurfaceNodes 的資料
    temp_grid_surface_node_data = temp_json_data["GridSurfaceNodes"]

    # 將資料轉換為 NumPy 陣列 (使用 object dtype 以容納 nan)
    grid_surface_node_array = np.array(temp_grid_surface_node_data, dtype=object)

    # 分離 X 和原始 Z 座標
    x_coords_original = grid_surface_node_array[:, 0].astype(float)
    z_coords_original = grid_surface_node_array[:, 1].astype(float)

    # 找到非 NaN 值的索引
    non_nan_z_indices = np.where(~np.isnan(z_coords_original))[0]

    # 如果有效的 Z 值不足，視為錯誤並終止程式
    if len(non_nan_z_indices) <= 1:
        print("錯誤：有效的 Z 值不足，無法進行內插。")
        exit(1)
    else:
        # 創建線性內插函數
        interpolate_function = interp1d(x_coords_original[non_nan_z_indices], z_coords_original[non_nan_z_indices], kind='linear', fill_value="extrapolate")

        # 找到 NaN 值的索引
        nan_z_indices = np.where(np.isnan(z_coords_original))[0]

        # 使用內插函數填補 NaN 值到 z_coords_interp
        z_coords_interp = z_coords_original.copy()
        z_coords_interp[nan_z_indices] = interpolate_function(x_coords_original[nan_z_indices])

        # 創建包含 X, 原始 Z 和內插 Z 的新陣列
        interpolated_data = np.column_stack((x_coords_original, z_coords_original, z_coords_interp))
        print("包含 X, 原始 Z 和內插 Z 的資料：")
        print(interpolated_data)

except FileNotFoundError:
    print(f"錯誤：找不到檔案 '{json_file_name}'")
    exit(1)
except json.JSONDecodeError:
    print(f"錯誤：檔案 '{json_file_name}' 不是有效的 JSON 格式")
    exit(1)
except KeyError as e:
    print(f"錯誤：JSON 檔案中找不到鍵 '{e}'")
    exit(1)
except ImportError:
    print("錯誤：找不到 scipy 函式庫，請先安裝 (pip install scipy)")
    exit(1)
except Exception as e:
    print(f"發生未知錯誤： {e}")
    exit(1)

```
